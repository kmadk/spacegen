{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":";AAEO,SAAS,oBAAoB,OAAuB;AACzD,QAAM,MAAM,KAAK,MAAM,KAAK,KAAK,KAAK,IAAI,OAAO,IAAI,CAAC,CAAC,IAAI;AAC3D,SAAO,KAAK,IAAI,GAAG,KAAK,IAAI,GAAG,GAAG,CAAC;AACrC;AAgBO,SAAS,kBACd,IACA,OAA2B,CAAC,GACd;AACd,QAAM,QAAQ,oBAAoB,KAAK,SAAS,CAAC;AACjD,QAAM,WAA2B,CAAC;AAClC,QAAM,QAAS,GAAG,IAAI,SAAS,CAAC;AAChC,QAAM,YAAY,oBAAI,IAAoB;AAC1C,QAAM,eAAgB,GAAG,aAAa,SAAS,CAAC;AAChD,aAAW,MAAM,aAAc,WAAU,IAAI,GAAG,IAAI,GAAG,QAAQ,GAAG,EAAE;AACpE,aAAW,KAAK,OAAO;AACrB,UAAM,IAAI,EAAE,MAAM;AAClB,QAAI,KAAK,MAAM,QAAQ,EAAE,KAAK,GAAG;AAC/B,YAAM,CAAC,KAAK,GAAG,IAAI,EAAE;AACrB,UAAI,QAAQ,OAAO,QAAQ,KAAK;AAC9B,YAAI,EAAE,cAAc,UAAU,IAAI,EAAE,UAAU,GAAG;AAC/C,mBAAS,KAAK;AAAA,YACZ,MAAM;AAAA,YACN,SAAS,UAAU,IAAI,EAAE,UAAU;AAAA,UACrC,CAAC;AAAA,QACH;AACA;AAAA,MACF;AAAA,IACF;AACA,UAAM,OAAqB;AAAA,MACzB,IAAI,EAAE;AAAA,MACN,MAAM,EAAE;AAAA,MACR,aAAa,EAAE;AAAA,MACf,UAAU,EAAE;AAAA,IACd;AAGA,QAAI,EAAE,YAAY,MAAM,QAAQ,EAAE,QAAQ,GAAG;AAC3C,YAAM,aAAa,MAAM,OAAO,CAAC,UAAU,EAAE,SAAS,SAAS,MAAM,EAAE,CAAC;AACxE,UAAI,WAAW,SAAS,GAAG;AACzB,aAAK,WAAW,WAAW,IAAI,CAAC,WAAW;AAAA,UACzC,IAAI,MAAM;AAAA,UACV,MAAM,MAAM;AAAA,UACZ,aAAa,MAAM;AAAA,UACnB,UAAU,MAAM;AAAA,QAClB,EAAE;AAAA,MACJ;AAAA,IACF;AAEA,aAAS,KAAK,IAAI;AAAA,EACpB;AACA,SAAO,EAAE,MAAM,OAAO,OAAO,SAAS;AACxC","sourcesContent":["import type { Json } from \"@fir/ir\";\n\nexport function deriveSemanticLevel(scale: number): number {\n  const lvl = Math.round(Math.log2(Math.max(scale, 0.01))) + 2;\n  return Math.max(0, Math.min(5, lvl));\n}\n\nexport type SemanticNode = {\n  id?: string;\n  type: string;\n  children?: SemanticNode[];\n  summary?: string;\n  renderHints?: any;\n  metadata?: any;\n};\nexport type SemanticTree = {\n  type: \"app\";\n  level: number;\n  children: SemanticNode[];\n};\n\nexport function buildSemanticTree(\n  ir: Json,\n  opts: { scale?: number } = {}\n): SemanticTree {\n  const level = deriveSemanticLevel(opts.scale ?? 1);\n  const children: SemanticNode[] = [];\n  const nodes = (ir.ui?.nodes ?? []) as any[];\n  const summaries = new Map<string, string>();\n  const summaryNodes = (ir.uiSummaries?.nodes ?? []) as any[];\n  for (const sn of summaryNodes) summaries.set(sn.id, sn.text || sn.id);\n  for (const n of nodes) {\n    const z = n.zoom?.semantic;\n    if (z && Array.isArray(z.range)) {\n      const [min, max] = z.range;\n      if (level < min || level > max) {\n        if (z.collapseTo && summaries.has(z.collapseTo)) {\n          children.push({\n            type: \"summary\",\n            summary: summaries.get(z.collapseTo),\n          });\n        }\n        continue;\n      }\n    }\n    const node: SemanticNode = {\n      id: n.id,\n      type: n.kind,\n      renderHints: n.renderHints,\n      metadata: n.metadata,\n    };\n\n    // Handle nested children if present\n    if (n.children && Array.isArray(n.children)) {\n      const childNodes = nodes.filter((child) => n.children.includes(child.id));\n      if (childNodes.length > 0) {\n        node.children = childNodes.map((child) => ({\n          id: child.id,\n          type: child.kind,\n          renderHints: child.renderHints,\n          metadata: child.metadata,\n        }));\n      }\n    }\n\n    children.push(node);\n  }\n  return { type: \"app\", level, children };\n}\n"]}