{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":";AACA,OAAO,QAAQ;AACf,OAAO,YAAY;AACnB,OAAO,SAAS;AAChB,OAAO,gBAAgB;AAIhB,SAAS,OAAO,MAAoB;AACzC,QAAM,MAAM,GAAG,aAAa,MAAM,MAAM;AACxC,SAAO,KAAK,MAAM,GAAG;AACvB;AAEO,SAAS,OAAO,MAAc,KAAW;AAC9C,QAAM,OAAO,KAAK,UAAU,KAAK,MAAM,CAAC;AACxC,KAAG,cAAc,MAAM,MAAM,MAAM;AACrC;AAEO,SAAS,aAAa,KAAiB;AAC5C,MAAI,MAAM,QAAQ,GAAG,EAAG,QAAO,IAAI,IAAI,YAAY;AACnD,MAAI,OAAO,OAAO,QAAQ,UAAU;AAClC,UAAM,OAAO,OAAO,KAAK,GAAG,EAAE,KAAK;AACnC,UAAM,MAAW,CAAC;AAClB,eAAW,KAAK,KAAM,KAAI,CAAC,IAAI,aAAa,IAAI,CAAC,CAAC;AAClD,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEO,SAAS,oBAAoB,KAAmB;AACrD,SAAO,KAAK,UAAU,aAAa,GAAG,CAAC;AACzC;AAEO,SAAS,OAAO,KAAmB;AACxC,QAAM,IAAI,OAAO,WAAW,QAAQ;AACpC,IAAE,OAAO,oBAAoB,GAAG,CAAC;AACjC,SAAO,EAAE,OAAO,KAAK;AACvB;AAEO,SAAS,WAAW,KAAW,QAAkD;AACtF,QAAM,MAAM,IAAI,IAAI,EAAE,WAAW,MAAM,QAAQ,MAAM,CAAC;AACtD,aAAW,GAAG;AACd,QAAM,WAAW,IAAI,QAAQ,MAAM;AACnC,QAAM,KAAK,SAAS,GAAG;AACvB,MAAI,CAAC,IAAI;AACP,UAAM,UAAU,SAAS,UAAU,CAAC,GAAG,IAAI,OAAK,GAAG,EAAE,YAAY,IAAI,EAAE,OAAO,EAAE;AAChF,WAAO,EAAE,IAAI,OAAO;AAAA,EACtB;AACA,SAAO,EAAE,IAAI,KAAK;AACpB","sourcesContent":["\nimport fs from 'node:fs';\nimport crypto from 'node:crypto';\nimport Ajv from 'ajv';\nimport addFormats from 'ajv-formats';\n\nexport type Json = any;\n\nexport function loadIR(path: string): Json {\n  const raw = fs.readFileSync(path, 'utf8');\n  return JSON.parse(raw);\n}\n\nexport function saveIR(path: string, obj: Json) {\n  const data = JSON.stringify(obj, null, 2);\n  fs.writeFileSync(path, data, 'utf8');\n}\n\nexport function canonicalize(obj: Json): Json {\n  if (Array.isArray(obj)) return obj.map(canonicalize);\n  if (obj && typeof obj === 'object') {\n    const keys = Object.keys(obj).sort();\n    const res: any = {};\n    for (const k of keys) res[k] = canonicalize(obj[k]);\n    return res;\n  }\n  return obj;\n}\n\nexport function canonicalJsonString(obj: Json): string {\n  return JSON.stringify(canonicalize(obj));\n}\n\nexport function irHash(obj: Json): string {\n  const h = crypto.createHash('sha256');\n  h.update(canonicalJsonString(obj));\n  return h.digest('hex');\n}\n\nexport function validateIR(obj: Json, schema: Json): { ok: boolean; errors?: string[] } {\n  const ajv = new Ajv({ allErrors: true, strict: false });\n  addFormats(ajv);\n  const validate = ajv.compile(schema);\n  const ok = validate(obj) as boolean;\n  if (!ok) {\n    const errors = (validate.errors || []).map(e => `${e.instancePath} ${e.message}`);\n    return { ok, errors };\n  }\n  return { ok: true };\n}\n"]}